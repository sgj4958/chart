<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>메인 페이지</title>

    <style>
        /* * {
            all: unset;
        } */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            list-style: none;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            padding: 50px;
            gap: 10px;
        }

        canvas {
            border: 1px solid #eee;
        }
    </style>
</head>
<body id="body">
    <canvas id="canvas" width="1000" height="500"></canvas>
</body>
<script>
    const chart = (canvasId, data, option) => {
        const optionDefault = {
            type: "bar",
            xAxisArray: [],
            yAxis: {
                min: 0,
                max: 0,
                step: 0,
                length: 10
            },
            graphColorArray: ["#87cefa99"],
            graphWidth: 10,
            beginAtZero: true,
        }
        option = {
            ...optionDefault,
            ...option
        }

        // const id = `customId_No${Math.floor(Math.random() * 10e5)}`
        document.head.insertAdjacentHTML("beforeend", `<style>
        </style>`)
        document.body.insertAdjacentHTML("afterbegin", `
        `)

        // const customWrap = document.querySelector("body")
        // const modalCustom = customWrap.querySelector(`#${id}`)

        const canvas = document.getElementById(canvasId)
        if(!canvas.getContext) return

        const ctx = canvas.getContext("2d", {alpha: false})
        const width = canvas.getBoundingClientRect().width
        const height = canvas.getBoundingClientRect().height

        const type = option.type
        const yMin = option.beginAtZero ? 0 : (option.yAxis.min || Math.min(...data))
        const yMax = option.yAxis.max || Math.max(...data)
        const yMaxCeil = Math.ceil(yMax / 10) * 10
        const interval = yMax - yMin

        const getAxisUnit = i => yMaxCeil / i > 10 ? getAxisUnit(i + 5) : i
        const axisUnit = {
            x: option.xAxisArray, 
            y: option.yAxis.step || getAxisUnit(5)
        }
        const lineNumber = {
            x: option.xAxisArray?.length || data.length, 
            y: option.yAxis.length || (yMaxCeil / axisUnit.y)
        }
        const graphWidth = option.graphWidth
        const padding = 50
        const labelMargin = {x: 10, y: 15}
        
        const graphAreaWidth = width - padding * 2
        const graphAreaHeight = height - padding * 2
        const xAxisWidth = graphAreaWidth / lineNumber.x
        const getValue = (i = 0) => data[i] / (axisUnit.y * lineNumber.y) * graphAreaHeight

        const drawGraph = () => {

        ctx.fillStyle = "#fff"
        ctx.fillRect(0, 0, width, height)
        ctx.fillStyle = "#aaa"
        ctx.strokeStyle = "#eee"

        // y축 그리기
        ctx.textAlign = "end"
        for(let i = 0; i < lineNumber.y + 1; i++) {
            const y = height - padding - graphAreaHeight / lineNumber.y * i
            ctx.fillText((i * axisUnit.y).toLocaleString(), padding, y + 3, 25)
            ctx.stroke(new Path2D(`M${padding + labelMargin.x} ${y + 0.5} h ${graphAreaWidth} Z`))
        }
        // x축 선 그리기
        for(let i = 0; i < lineNumber.x + 1; i++) {
            const x = padding + xAxisWidth * i
            ctx.stroke(new Path2D(`M${x + labelMargin.x + 0.5} ${height - padding} v -${graphAreaHeight} Z`))
        }
        ctx.textAlign = "center"
        // x축 텍스트 그리기
        for(let i = 0; i < lineNumber.x; i++) {
            const x = padding + xAxisWidth * i
            axisUnit.x.length && ctx.fillText(`${axisUnit.x[i]}`.toLocaleString(), x + labelMargin.x + xAxisWidth / 2, height - padding + labelMargin.y, 25)
        }
        // 그래프 그리기
        for(let i = 0; i < lineNumber.x; i++) {
            const x = padding + xAxisWidth * i
            ctx.fillStyle = option.graphColorArray[i] || option.graphColorArray
            ctx.fill(new Path2D(`M${x + labelMargin.x - graphWidth / 2 + xAxisWidth / 2 + 0.5} ${height - padding} h ${graphWidth} v -${getValue(i)} h -${graphWidth} Z`))
        }
        
        }
        drawGraph()
        
        const drawToolTipIcon = (x, y, width, height, radius) => {
            ctx.fillStyle = "#555"
            // ctx.beginPath();
            // ctx.moveTo(x, y + radius);
            // ctx.lineTo(x, y + height - radius);
            // ctx.arcTo(x, y + height, x + radius, y + height, radius);

            // ctx.lineTo(x + width / 2 - 5, y + height);
            // ctx.lineTo(x + width / 2 , y + height + 5);
            // ctx.lineTo(x + width / 2 + 5, y + height);
            // ctx.lineTo(x + width - radius, y + height);

            // ctx.arcTo(x + width, y + height, x + width, y + height - radius, radius);
            // ctx.lineTo(x + width, y + radius);
            // ctx.arcTo(x + width, y, x + width - radius, y, radius);
            // ctx.lineTo(x + radius, y);
            // ctx.arcTo(x, y, x, y + radius, radius);
            // // ctx.stroke();
            // ctx.fill()

            ctx.moveTo(x + radius, y)

            ctx.lineTo(x + width - radius, y)
            ctx.arcTo(x + width, y, x + width, y + radius, radius)
            ctx.lineTo(x + width, y + height - radius)

            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius)

            ctx.lineTo(x + width / 2 + 5, y + height)
            ctx.lineTo(x + width / 2, y + height + 5)
            ctx.lineTo(x + width / 2 - 5, y + height)

            ctx.lineTo(x + radius, y + height)

            ctx.arcTo(x, y + height, x, y + height - radius, radius)
            ctx.lineTo(x, y + radius)

            ctx.arcTo(x, y, x + radius, y, radius)
            ctx.fill()
        }

        const reset = () => {
            ctx.reset()
            drawGraph()
        }

        canvas.addEventListener("mousemove", event => {
            const x = event.x - canvas.getBoundingClientRect().x
            const y = event.y - canvas.getBoundingClientRect().y
            for(let i = 0; i < lineNumber.x; i++) {
                const now = padding + labelMargin.x + xAxisWidth * i + xAxisWidth / 2
                if((x > now - xAxisWidth / 2) && (now + xAxisWidth / 2 > x)) {
                    reset()
                    const text = `${option.xAxisArray[i] ? option.xAxisArray[i] + " :" : ""} ${data[i]}`
                    const measureText = ctx.measureText(text)
                    
                    const toolTipPadding = 30
                    const toolTipWidth = measureText.width + toolTipPadding
                    const toolTipHeight = 30
                    const toolTipX = now - toolTipWidth / 2
                    const toolTipY = height - padding - getValue(i) - toolTipHeight - 5
                    drawToolTipIcon(toolTipX, toolTipY, toolTipWidth, toolTipHeight, 10)

                    ctx.font = "14px sans-serif"
                    ctx.textAlign = "center"
                    ctx.textBaseline = "middle"
                    ctx.fillStyle = "#fff"
                    ctx.fillText(text, toolTipX + toolTipWidth / 2, toolTipY + toolTipHeight / 2, toolTipWidth)

                    return
                }
            }
            reset()
        })
    }

    chart("canvas", [11, 30, 25, 67, 50, 76, 90, 123, 80, 30, 55, 90], {xAxisArray: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"]})
</script>
</html>